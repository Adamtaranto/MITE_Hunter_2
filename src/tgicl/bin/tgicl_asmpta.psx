#!/usr/bin/perl
use strict;
use FindBin;
umask 0002;

chdir($ENV{PVMSX_WD}) if ($ENV{PVMSX_WD});

my ($file, $numpass, $seqnum, $last, $skipped, $total, $userparams)=@ARGV;

$ENV{'PATH'}=$FindBin::Bin.':'.$ENV{'PATH'};
$ENV{'PTAHOME'}='/usr/local/packages/tgi/paracel/CurrentRelease'
 unless $ENV{'PTAHOME'};
# this should be already set -- if not, please replace here with 
# your PTAHOME value -- 
 
#user values:
#my ($ydbfile, $asmopts, $qualidx, $paramfile, $limits) = split(/:/,$userparams);
my ($ydbfile, $asmopts, $qualidx, $pta_params, $limits)=split(/:/,$userparams);
my ($pid, $minovl, $maxovh)=split(/\~/,$limits);
$pid=94 if $pid<50;
$minovl=40 unless $minovl;
$maxovh=30 unless $maxovh;
$asmopts =~ s/\~\+/ /g;
my $to_yank=$file.'.ynk';
my $log_file='log_std';
my $err_file='err_log';

open(STDERR, '>>'.$err_file);
open(STDOUT, '>>'.$log_file);
open(CLFILE, '<'.$file);
$_=<CLFILE> until (m/^>(\S+)\s+(\d+)/ || eof(CLFILE));
my ($cl_id, $cl_count)=($1,$2);
die(" Error parsing cluster defline for '$file'.\n".
  "It must be cluster_name followed by number of sequences.\n")
 if ($cl_count<2);
 
{
 local $/=undef;
 $_=<CLFILE>; 
 tr/ \t/\n\n/; #here is the cluster
}
close(CLFILE);
   
open(YANKIN, '>'.$to_yank);
print YANKIN $_;
close(YANKIN);
print ">>Cluster $cl_id ($cl_count):\n"; #this will go to STDOUT logfile

my $to_asm=$cl_id;

if (-e '../.stop_at') {
 my $r=`cat ../.stop_at`;
 chomp($r);
 if ($r eq $cl_id) {
   print STDERR "Stopped by request from ../.stop_at file (cluster $r)\n";
   exit(1);
   }
}

system("cdbyank $ydbfile < $to_yank > $to_asm");
if ($?) {
  print STDERR "Error yanking sequences:\n";
  print STDERR " at cdbyank $ydbfile < $to_yank > $to_asm\n";
  exit(1);
  }

if ($qualidx) {
 system("cdbyank $qualidx < $to_yank > $to_asm.qual")
   && die("Error pulling the quality values for cluster $cl_id ($to_asm)\n");
 }

  
unlink($file, $to_yank);
#now assemble it:
my $cap_ace= $to_asm.'.cap.ace';

#=- PTA stuff
my $mcaml=$to_asm.'.caml';
my $cmd="sequtil $to_asm -out $mcaml -format caml";
system($cmd) && die "Error at caml conversion: '$cmd'\n";
unless (-e 'pta_asm.prm') {
 if ($pta_params && -e $pta_params) {
   system("cp $pta_params pta_asm.prm");
   }
 else { 
   $pid=sprintf("%4.2f",$pid/100);
   open (ASMPRM, '>pta_asm.prm') || die "Cannot create pta_asm.prm\n";
   print ASMPRM qq/
   -Percent $pid
   -OverlapLen $minovl
   -Verbosity   0
   -MinCovRep   80000
   -InOverhang     $maxovh
   -EndOverhang    40
   -RemOverhang    40
   -QualSumLim    300
   -ClipByBadEnd
   -ExtraPenalty 4
   -ESTAssembly 
   -MaxInternalGaps 10
   -OrientContigBy 2
   -PenalizeN  0
   -IgnorePolyMaskChars
   -KeepDups
   -NoPolyBaseMask
   -ClipLimitConfirm
   -ChimeraOut
   -ChimSidesCov 20
    /;
   close ASMPRM;
   }
 }
$cmd="pa.pta $mcaml -Param pta_asm.prm -AceFile $cap_ace";
system($cmd) && die "Error at pa.pta run: '$cmd'\n";
unlink($mcaml, $mcaml.'assem.caml');
#===
   
my $errcode=$?;
if ($errcode) {
  print STDERR "Error! cap3 failure detected (code=$errcode) on: $to_asm\n";
  exit(0); #exit, but do not report error 
           #- so we can continue to assemble the rest of the clusters!
  }

system("cat $cap_ace | sed 's/^CO /CO ${cl_id}/' >> ACE");
&catErr($cap_ace) if ($?);

unlink($to_asm);
unlink($file);
$to_asm.='*';
unlink(<${to_asm}>);
print "<<  finished $cl_id \n";


#==================
sub catErr {
 print STDERR "Error appending $_[0]\n",
    "(Not enough space on device?)\n";
 exit(1);   
}
